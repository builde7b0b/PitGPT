/**
 * Service to load and sync Python-computed race metrics with the UI
 * Reads from race_metrics.csv generated by compute_metrics.py
 */

export interface PythonRaceMetrics {
  driver_id: string;
  vehicle_number: number;
  tire_stress_index: number;
  attack_window: number;
  fuel_conservation_mode: number;
  overtake_risk: number;
  ideal_pit_window: number;
}

export interface DriverMetrics {
  driverId: string;
  vehicleNumber: number;
  tireStressIndex: number;
  attackWindow: number;
  fuelConservationMode: number;
  overtakeRisk: number;
  idealPitWindow: number;
}

let cachedMetrics: DriverMetrics[] | null = null;

/**
 * Load race metrics from CSV file
 * In production, this would fetch from an API endpoint
 */
export async function loadRaceMetrics(): Promise<DriverMetrics[]> {
  if (cachedMetrics) {
    return cachedMetrics;
  }

  try {
    // Fetch the CSV file (assuming it's served from the public directory)
    const response = await fetch('/race_metrics.csv');
    
    if (!response.ok) {
      console.warn('Could not load race_metrics.csv, using fallback');
      return getFallbackMetrics();
    }

    const csvText = await response.text();
    const lines = csvText.trim().split('\n');
    const headers = lines[0].split(',');
    
    const metrics: DriverMetrics[] = [];
    
    for (let i = 1; i < lines.length; i++) {
      const values = lines[i].split(',');
      if (values.length < 7) continue;
      
      const row: Record<string, string> = {};
      headers.forEach((header, idx) => {
        row[header.trim()] = values[idx]?.trim() || '0';
      });

      metrics.push({
        driverId: row.driver_id || '',
        vehicleNumber: parseInt(row.vehicle_number) || 0,
        tireStressIndex: parseFloat(row.tire_stress_index) || 0,
        attackWindow: parseFloat(row.attack_window) || 0,
        fuelConservationMode: parseFloat(row.fuel_conservation_mode) || 0,
        overtakeRisk: parseFloat(row.overtake_risk) || 0,
        idealPitWindow: parseFloat(row.ideal_pit_window) || 0,
      });
    }

    cachedMetrics = metrics;
    return metrics;
  } catch (error) {
    console.error('Error loading race metrics:', error);
    return getFallbackMetrics();
  }
}

/**
 * Get metrics for a specific driver by vehicle number
 */
export async function getDriverMetrics(vehicleNumber: number): Promise<DriverMetrics | null> {
  const allMetrics = await loadRaceMetrics();
  return allMetrics.find(m => m.vehicleNumber === vehicleNumber) || null;
}

/**
 * Convert Python metrics to UI RaceMetrics format
 */
export function pythonMetricsToUIMetrics(pythonMetrics: DriverMetrics): {
  tireStressIndex: number;
  overtakeRiskScore: number;
  attackWindow: boolean;
  fuelConservationMode: boolean;
  idealPitWindow: number;
  lapPaceTrend: number;
  brakeStress: number;
} {
  return {
    tireStressIndex: Math.min(100, pythonMetrics.tireStressIndex * 10), // Scale to 0-100
    overtakeRiskScore: pythonMetrics.overtakeRisk * 100, // Already 0-1, scale to 0-100
    attackWindow: pythonMetrics.attackWindow > 0.3, // Threshold for attack window
    fuelConservationMode: pythonMetrics.fuelConservationMode > 0.3, // Threshold
    idealPitWindow: pythonMetrics.idealPitWindow,
    lapPaceTrend: 0, // Would need lap time data for this
    brakeStress: pythonMetrics.tireStressIndex * 5, // Approximate brake stress from tire stress
  };
}

/**
 * Fallback metrics if CSV can't be loaded (for development)
 */
function getFallbackMetrics(): DriverMetrics[] {
  return [
    {
      driverId: 'GR86-022-13',
      vehicleNumber: 13,
      tireStressIndex: 8.772,
      attackWindow: 0.352,
      fuelConservationMode: 0.294,
      overtakeRisk: 0.793,
      idealPitWindow: 0.005,
    },
    {
      driverId: 'GR86-060-2',
      vehicleNumber: 2,
      tireStressIndex: 9.878,
      attackWindow: 0.307,
      fuelConservationMode: 0.300,
      overtakeRisk: 0.818,
      idealPitWindow: 0.004,
    },
    {
      driverId: 'GR86-047-21',
      vehicleNumber: 21,
      tireStressIndex: 9.125,
      attackWindow: 0.372,
      fuelConservationMode: 0.309,
      overtakeRisk: 1.000,
      idealPitWindow: 0.004,
    },
  ];
}

/**
 * Clear cache (useful for refreshing data)
 */
export function clearMetricsCache(): void {
  cachedMetrics = null;
}

